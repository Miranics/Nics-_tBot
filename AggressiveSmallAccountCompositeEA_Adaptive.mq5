//+------------------------------------------------------------------+
//| Expert Advisor: AggressiveSmallAccountCompositeEA_Adaptive       |
//| Purpose: Composite regime-based EA with adaptive risk sizing     |
//| Platform: MetaTrader 5 (MQL5)                                    |
//| Author: (Generated by AI)                                        |
//| Disclaimer: HIGH RISK. 10% sizing on ~$20 can cause rapid        |
//| drawdowns. Adaptive logic does NOT guarantee capital             |
//| preservation. USE DEMO FIRST.                                    |
//+------------------------------------------------------------------+
#property copyright "Open Source"
#property version   "1.000"
#property strict
#property description "Aggressive small account composite EA with adaptive risk sizing, pullback & compression entries, multi-timeframe filters, protections."

#include <Arrays/ArrayObj.mqh>

//==================================================================//
// Inputs & Enums                                                   //
//==================================================================//
enum SLModeEnum { SLMODE_ATR=0, SLMODE_SWING=1 };
enum TrailingModeEnum { TRAIL_NONE=0, TRAIL_ATR=1, TRAIL_SWING=2 }; 
enum EntryType { ENTRY_NONE=0, ENTRY_PULLBACK=1, ENTRY_COMPRESSION=2 }; 

enum LogLevel { LOG_ERROR=0, LOG_IMPORTANT=1, LOG_VERBOSE=2, LOG_DEBUG=3 };

input string  InpSymbolsWhitelist = "EURUSD,XAUUSD"; // Comma separated symbols
input ENUM_TIMEFRAMES InpChartTF = PERIOD_M15;
input ENUM_TIMEFRAMES InpHTFTrendTF = PERIOD_H1;
// Trend EMAs
input int fastEMA_HTF=50; input int slowEMA_HTF=200; 
input int fastEMA_LTF=20; input int slowEMA_LTF=50; 
// Lower timeframe confirmations
input bool InpEnableLTFConfirmation=true; 
input ENUM_TIMEFRAMES InpLTFConfirmTF=PERIOD_M5; 
input bool InpRequireMicroTF=false; 
input ENUM_TIMEFRAMES InpMicroTF=PERIOD_M1; 
input int InpLTF_FastEMA=9; input int InpLTF_SlowEMA=21; 
input int InpMicro_FastEMA=5; input int InpMicro_SlowEMA=13; 
// Volatility
input int atrPeriod=14; 
input int minATRPointsDefault=120; input int maxATRPointsDefault=2500; 
input int minATRPointsGold=150; input int maxATRPointsGold=6000; 
// Pullback
input double pullbackDepthLower=0.985; input double pullbackDepthUpper=1.015; 
input double minBodyFraction=0.4; input double minWickFraction=0.3; 
// Compression
input int compressionCandles=4; input double compressionFactor=0.55; 
input int breakoutBufferPoints=30; input int pendingExpiryBars=6; 
// Stops & RR
input SLModeEnum InpSLMode = SLMODE_ATR; 
input double atrStopMultDefault=1.3; input double atrStopMultGold=1.0; 
input int swingLookbackBars=8; 
input double rrPrimary=2.0; input double rrSecondary=3.5; 
// Partial & Trailing
input bool partialTPEnabled=true; input double partialTP_R=1.0; input double partialTPPercent=40; 
input TrailingModeEnum trailingMode=TRAIL_ATR; input double trailingATRMult=1.0; input double breakEvenBufferFraction=0.05; 
// Risk Core
input double baseRiskPercent=10.0; input double reducedRiskPercent=3.0; 
input bool dynamicRiskThrottle=true; input double dynamicDrawdownThresholdPercent=15; 
input double growthThresholdMultiple=1.5; input double maxDollarRiskPerTrade=3.0; 
input double allowedRiskTolerancePct=20; input bool skipIfOverRisk=true; 
input int consecutiveLossHalt=5; 
// Adaptive Sizing
input bool adaptiveSizingEnabled=true; input int winRateWindow=20; input int minTradesForAdapt=12; 
input double kellyScalingFactor=0.5; input double minRiskPercent=2.0; input double maxRiskPercent=12.0; 
input double adaptSmoothing=0.6; input double negativeKellyFallback=2.5; 
// Protections
input double maxDailyLossPercent=15; input double dailyProfitLockPercent=10; input double equityFloorPercentOfDayStart=70; 
input int maxOpenPositionsTotal=2; input int maxOpenPerSymbol=1; 
// Sessions
input string tradingSessionStart="07:00"; input string tradingSessionEnd="17:00"; 
input string goldSessionStart="06:00"; input string goldSessionEnd="18:00"; 
// Execution
input int maxSpreadPoints=300; input int slippagePoints=80; 
// IDs
input long baseMagicNumber=20250822; 
// Logging
input int logVerbosity=2; input string logPrefix="SMALL-ADAPT-EA"; 
// Misc
input bool futurePyramidingEnabled=false; input bool enableNewsFilterStub=true; 

//==================================================================//
// Structs                                                          //
//==================================================================//
class SymbolProfile : public CObject {
public:
   string symbol;
   bool   isGold;
   int    minATRPoints;
   int    maxATRPoints;
   double atrStopMult;
};

class PositionState : public CObject {
public:
   ulong  ticket;
   string symbol;
   double entryPrice;
   double stopLossPrice;
   double takeProfitPrice;
   double initialRiskAmount; // currency
   double initialStopPoints;
   bool   partialTaken;
   double rrPrimary;
   double rrSecondary;
   int    direction; // 1 long, -1 short
   datetime openTime;
   bool   isCompressionPending; // for pending orders
   datetime pendingPlacedTime;
   double compressionHigh;
   double compressionLow;
   int    expiryBars;
   bool   counted;
};

class TradePerformanceRecord : public CObject {
public:
   ulong ticket;
   double riskAmount;
   double profitAmount;
   double rMultiple;
   datetime closeTime;
};

struct GlobalState {
   double dayStartEquity;
   datetime dayDate;
   double peakEquity;
   bool throttleActive;
   int consecutiveLosses;
   double lastAdaptiveRiskPercent;
};

//==================================================================//
// Global Variables / Arrays                                        //
//==================================================================//
CArrayObj g_symbolProfiles; // objects of SymbolProfile
CArrayObj g_positions;       // PositionState (open or pending states we track)
CArrayObj g_performance;     // TradePerformanceRecord ring
string   g_symbols[];        // whitelist
GlobalState g_state;
int      g_digits=5;

//==================================================================//
// Forward Declarations                                              //
//==================================================================//
bool AllowNewTrade(const string symbol, string &reason);
int  HTFTrendBias(const string symbol); // 1 long, -1 short, 0 none
bool LTFTrendAlignment(const string symbol,int bias);
bool LowerTFConfirm(const string symbol,int bias);
bool VolatilityOK(const string symbol,double &atrPoints);
EntryType EvaluateEntry(const string symbol,int bias,double atrPoints, double &pullbackPrice, double &compHigh, double &compLow);
bool BuildPullbackSignal(const string symbol,int bias,double &entryPrice);
bool BuildCompressionSignal(const string symbol,int bias,double &highBox,double &lowBox);
bool ComputeStopPoints(const string symbol,int bias,double atrPoints,double &stopLossPoints,double &entryPrice,double &tpPrimary,double &tpSecondary, SLModeEnum mode, double rr1,double rr2);
double ComputeLotSize(const string symbol,double stopLossPoints,double targetRiskCurrency,bool &skip,string &reason);
double ComputeAdaptiveRiskPercent();
void EvaluateDynamicRiskThrottle();
bool PlaceTrade(const string symbol,EntryType et,int bias,double atrPoints,double entryPrice,double compHigh,double compLow,string &reason);
void ManageOpenPositions();
void ApplyTrailing(PositionState &ps,double atrPoints);
void RecordClosedTrade();
bool CheckDailyProtections(string &reason);
void Log(int level,string tag,string msg);
bool ModifyPositionSLTP(ulong position_ticket,double newSL,double newTP);
ulong GetPositionTicketBySymbol(const string symbol);

// Utility helpers
int SplitString(const string s, const string delimiter, string &arr[]);
bool SessionOpen(const string symbol);
bool NewsFilterOK();
SymbolProfile* GetProfile(const string symbol);
PositionState* FindPositionByTicket(ulong ticket);
int CountOpenPositionsSymbol(const string symbol);
int CountAllOpenPositions();
void RefreshTrackedPositions();

//==================================================================//
// Utility & Indicator Functions                                    //
//==================================================================//
int SplitString(const string s, const string delimiter, string &arr[]){
   StringTrimRight(s); StringTrimLeft(s);
   int parts=0; string tmp=s; int pos=StringFind(tmp,delimiter,0);
   while(pos>=0){
      string left=StringSubstr(tmp,0,pos);
      if(StringLen(left)>0){ ArrayResize(arr,parts+1); arr[parts++]=StringTrim(left); }
      tmp=StringSubstr(tmp,pos+StringLen(delimiter));
      pos=StringFind(tmp,delimiter,0);
   }
   if(StringLen(tmp)>0){ ArrayResize(arr,parts+1); arr[parts++]=StringTrim(tmp);} 
   return parts;
}

bool NewsFilterOK(){
   if(!enableNewsFilterStub) return true;
   // Placeholder always true
   return true;
}

bool IsGold(const string symbol){ return (StringFind(symbol,"XAU")==0 || symbol=="XAUUSD"); }

SymbolProfile* GetProfile(const string symbol){
   for(int i=0;i<g_symbolProfiles.Total();++i){
      SymbolProfile *p=(SymbolProfile*)g_symbolProfiles.At(i);
      if(p!=NULL && p->symbol==symbol) return p;
   }
   return NULL;
}

PositionState* FindPositionByTicket(ulong ticket){
   for(int i=0;i<g_positions.Total();++i){ PositionState *ps=(PositionState*)g_positions.At(i); if(ps && ps->ticket==ticket) return ps; }
   return NULL;
}

int CountOpenPositionsSymbol(const string symbol){
   int c=0;
   for(int i=0;i<PositionsTotal();++i){ if(PositionSelectByIndex(i)){ if(PositionGetString(POSITION_SYMBOL)==symbol) c++; }}
   return c;
}

int CountAllOpenPositions(){ return PositionsTotal(); }

bool GetEMAs(const string symbol, ENUM_TIMEFRAMES tf,int fast,int slow,double &fastVal,double &slowVal){
   int shift=1; // last closed
   fastVal=iMA(symbol,tf,fast,0,MODE_EMA,PRICE_CLOSE,shift);
   slowVal=iMA(symbol,tf,slow,0,MODE_EMA,PRICE_CLOSE,shift);
   if(fastVal==0 || slowVal==0) return false;
   return true;
}

double GetATRPoints(const string symbol, ENUM_TIMEFRAMES tf,int period){
   double val=iATR(symbol,tf,period,1);
   if(val<=0) return 0; 
   double point=SymbolInfoDouble(symbol,SYMBOL_POINT);
   if(point<=0) point=_Point; 
   return val/point; // points
}

bool PriceOnCorrectSide(const string symbol,int bias,double slowHTF){
   double price = SymbolInfoDouble(symbol,SYMBOL_BID);
   if(bias==1) return price>slowHTF; else if(bias==-1) return price<slowHTF; return false;
}

bool SessionOpen(const string symbol){
   datetime now = TimeCurrent(); MqlDateTime st; TimeToStruct(now,st);
   string sessStart = IsGold(symbol)?goldSessionStart:tradingSessionStart;
   string sessEnd   = IsGold(symbol)?goldSessionEnd:tradingSessionEnd;
   int sh=0, sm=0, eh=23, em=59;
   if(StringLen(sessStart)>=4){ sh=(int)StringToInteger(StringSubstr(sessStart,0,2)); sm=(int)StringToInteger(StringSubstr(sessStart,3,2)); }
   if(StringLen(sessEnd)>=4){ eh=(int)StringToInteger(StringSubstr(sessEnd,0,2)); em=(int)StringToInteger(StringSubstr(sessEnd,3,2)); }
   datetime start=StructToTime(st) - (st.hour*3600+st.min*60+st.sec) + sh*3600 + sm*60;
   datetime end  =StructToTime(st) - (st.hour*3600+st.min*60+st.sec) + eh*3600 + em*60;
   return (now>=start && now<=end);
}

bool VolatilityOK(const string symbol,double &atrPoints){
   SymbolProfile *prof=GetProfile(symbol); if(!prof){ return false; }
   atrPoints=GetATRPoints(symbol,InpChartTF,atrPeriod);
   if(atrPoints<=0) return false;
   if(atrPoints < prof.minATRPoints || atrPoints > prof.maxATRPoints) return false;
   return true;
}

//==================================================================//
// Volatility / Trend / Confirmation Functions                      //
//==================================================================//
int HTFTrendBias(const string symbol){
   double f,s; if(!GetEMAs(symbol,InpHTFTrendTF,fastEMA_HTF,slowEMA_HTF,f,s)) return 0;
   double price=SymbolInfoDouble(symbol,SYMBOL_BID);
   if(f>s && price>s) return 1; if(f<s && price<s) return -1; return 0;
}

bool LTFTrendAlignment(const string symbol,int bias){
   double f,s; if(!GetEMAs(symbol,InpChartTF,fastEMA_LTF,slowEMA_LTF,f,s)) return false; 
   if(bias==1 && f>s) return true; if(bias==-1 && f<s) return true; return false; }

bool LowerTFConfirm(const string symbol,int bias){
   if(!InpEnableLTFConfirmation) return true;
   double f1,s1; if(!GetEMAs(symbol,InpLTFConfirmTF,InpLTF_FastEMA,InpLTF_SlowEMA,f1,s1)) return false; 
   if(bias==1 && f1<=s1) return false; if(bias==-1 && f1>=s1) return false; 
   if(InpRequireMicroTF){
      double f2,s2; if(!GetEMAs(symbol,InpMicroTF,InpMicro_FastEMA,InpMicro_SlowEMA,f2,s2)) return false;
      if(bias==1 && f2<=s2) return false; if(bias==-1 && f2>=s2) return false;
   }
   return true;
}

bool SpreadOK(const string symbol){
   double spread = (SymbolInfoInteger(symbol,SYMBOL_SPREAD)); // in points
   return spread <= maxSpreadPoints;
}

//==================================================================//
// Entry Signal Builders                                             //
//==================================================================//
bool BuildPullbackSignal(const string symbol,int bias,double &entryPrice){
   // Use last closed candle
   MqlRates rates[]; if(CopyRates(symbol,InpChartTF,1,3,rates)!=3) return false;
   MqlRates c=rates[0]; // last closed
   double fast=iMA(symbol,InpChartTF,fastEMA_LTF,0,MODE_EMA,PRICE_CLOSE,1);
   if(fast<=0) return false;
   double ratio = c.close/fast; if(ratio < pullbackDepthLower || ratio > pullbackDepthUpper) return false;
   double body = MathAbs(c.close - c.open);
   double range = c.high - c.low; if(range<=0) return false;
   if(body / range < minBodyFraction) return false;
   double wickDir=0;
   if(bias==1){ // long want lower rejection
      double lowerWick = (MathMin(c.open,c.close) - c.low);
      if(body==0) return false;
      if(lowerWick / body < minWickFraction) return false;
      if(c.close <= c.open) return false; // need bullish
   } else if(bias==-1){
      double upperWick = (c.high - MathMax(c.open,c.close));
      if(body==0) return false;
      if(upperWick / body < minWickFraction) return false;
      if(c.close >= c.open) return false; // need bearish
   }
   entryPrice = SymbolInfoDouble(symbol, bias==1?SYMBOL_ASK:SYMBOL_BID);
   return true;
}

bool BuildCompressionSignal(const string symbol,int bias,double &highBox,double &lowBox){
   MqlRates rates[]; if(CopyRates(symbol,InpChartTF,1,compressionCandles,rates)!=compressionCandles) return false;
   double atrPoints=GetATRPoints(symbol,InpChartTF,atrPeriod);
   double point=SymbolInfoDouble(symbol,SYMBOL_POINT); if(point<=0) point=_Point;
   if(atrPoints<=0) return false;
   double atrPrice=atrPoints*point;
   double maxHigh=-DBL_MAX,minLow=DBL_MAX; 
   for(int i=0;i<compressionCandles;i++){
      double r = rates[i].high - rates[i].low;
      if(r > compressionFactor*atrPrice) return false; // not compressed
      if(rates[i].high>maxHigh) maxHigh=rates[i].high;
      if(rates[i].low<minLow) minLow=rates[i].low;
   }
   highBox=maxHigh; lowBox=minLow;
   return true;
}

EntryType EvaluateEntry(const string symbol,int bias,double atrPoints, double &pullbackPrice,double &compHigh,double &compLow){
   pullbackPrice=0; compHigh=0; compLow=0; 
   // Priority: Pullback first
   if(BuildPullbackSignal(symbol,bias,pullbackPrice)) return ENTRY_PULLBACK;
   if(BuildCompressionSignal(symbol,bias,compHigh,compLow)) return ENTRY_COMPRESSION;
   return ENTRY_NONE;
}

//==================================================================//
// Risk & Sizing                                                     //
//==================================================================//

double PointValuePerPoint(const string symbol){
   double tickValue=SymbolInfoDouble(symbol,SYMBOL_TRADE_TICK_VALUE);
   double tickSize=SymbolInfoDouble(symbol,SYMBOL_TRADE_TICK_SIZE);
   double point=SymbolInfoDouble(symbol,SYMBOL_POINT); if(point<=0) point=_Point;
   if(tickSize<=0) return 0; 
   double valuePerPriceUnit = tickValue / tickSize; // per 1.0 price move
   return valuePerPriceUnit * point; // per point
}

bool ComputeStopPoints(const string symbol,int bias,double atrPoints,double &stopLossPoints,double &entryPrice,double &tpPrimary,double &tpSecondary, SLModeEnum mode, double rr1,double rr2){
   double point=SymbolInfoDouble(symbol,SYMBOL_POINT); if(point<=0) point=_Point;
   double price = SymbolInfoDouble(symbol,bias==1?SYMBOL_ASK:SYMBOL_BID);
   entryPrice=price;
   if(mode==SLMODE_ATR){
   SymbolProfile *p=GetProfile(symbol); double mult = p?p->atrStopMult:1.2;
      stopLossPoints = atrPoints * mult;
   } else { // swing mode
      int look=swingLookbackBars; MqlRates rates[]; if(CopyRates(symbol,InpChartTF,1,look+5,rates) < look+1) return false;
      double extreme=bias==1?DBL_MAX:-DBL_MAX; 
      for(int i=0;i<look;i++){
         if(bias==1){ if(rates[i].low < extreme) extreme=rates[i].low; }
         else { if(rates[i].high > extreme) extreme=rates[i].high; }
      }
      if(extreme<=0) return false;
      double dist = MathAbs(price - extreme)/point; if(dist<=0) return false;
      stopLossPoints = dist;
   }
   if(stopLossPoints<1) return false;
   tpPrimary = rr1 * stopLossPoints;
   tpSecondary = rr2 * stopLossPoints;
   return true;
}

double ComputeAdaptiveRiskPercent(){
   if(!adaptiveSizingEnabled){ return baseRiskPercent; }
   int n=g_performance.Total(); if(n<minTradesForAdapt){ return baseRiskPercent; }
   int countConsider=0; double wins=0; double sumWinR=0; double sumLossR=0; int lossCount=0;
   for(int i= MathMax(0,n-winRateWindow); i<n; ++i){
      TradePerformanceRecord *tr=(TradePerformanceRecord*)g_performance.At(i); if(!tr) continue;
      double R=tr.rMultiple; if(R>0){ wins++; sumWinR += R; } else { lossCount++; sumLossR += MathAbs(R); }
      countConsider++;
   }
   if(countConsider<minTradesForAdapt) return baseRiskPercent;
   double p = wins / countConsider; if(p<=0) return negativeKellyFallback;
   double avgWinR = wins>0 ? sumWinR / wins : 1.0; if(avgWinR<=0) avgWinR=1.0;
   double avgLossR = lossCount>0? sumLossR / lossCount : 1.0; // losses positive
   // Use simplified Kelly with R = avgWinR/avgLossR for risk-reward ratio
   double Rratio = avgWinR/avgLossR; if(Rratio<=0) Rratio=1.0;
   double f = (p*(Rratio+1)-1)/Rratio; // Kelly fraction
   if(f<=0) f = negativeKellyFallback/100.0; // fallback percent to fraction
   double rawPercent = f * 100.0 * kellyScalingFactor;
   rawPercent = MathMax(minRiskPercent, MathMin(maxRiskPercent, rawPercent));
   // Growth scaling
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   if(g_state.dayStartEquity>0 && equity >= growthThresholdMultiple * g_state.dayStartEquity){
      rawPercent = MathMin(rawPercent, baseRiskPercent*0.6);
   }
   // Throttle
   if(dynamicRiskThrottle && g_state.throttleActive){ rawPercent = MathMin(rawPercent, reducedRiskPercent); }
   // Smooth
   double result = (g_state.lastAdaptiveRiskPercent*adaptSmoothing) + (rawPercent*(1.0-adaptSmoothing));
   g_state.lastAdaptiveRiskPercent = result;
   return result;
}

void EvaluateDynamicRiskThrottle(){
   double equity=AccountInfoDouble(ACCOUNT_EQUITY);
   if(equity>g_state.peakEquity) g_state.peakEquity = equity;
   double ddPct = g_state.peakEquity>0 ? ( (g_state.peakEquity - equity)/g_state.peakEquity * 100.0 ) : 0.0;
   if(dynamicRiskThrottle){
      if(!g_state.throttleActive && ddPct >= dynamicDrawdownThresholdPercent){ g_state.throttleActive=true; Log(LOG_IMPORTANT,"THROTTLE","Activated dd="+DoubleToString(ddPct,2)); }
      if(g_state.throttleActive && ddPct < dynamicDrawdownThresholdPercent*0.5){ g_state.throttleActive=false; Log(LOG_IMPORTANT,"THROTTLE","Deactivated dd="+DoubleToString(ddPct,2)); }
   }
}

bool AllowNewTrade(const string symbol,string &reason){
   if(!SessionOpen(symbol)){ reason="SESSION_CLOSED"; return false; }
   if(!NewsFilterOK()){ reason="NEWS_FILTER"; return false; }
   if(CountAllOpenPositions() >= maxOpenPositionsTotal){ reason="POSITION_LIMIT"; return false; }
   if(CountOpenPositionsSymbol(symbol) >= maxOpenPerSymbol){ reason="SYMBOL_LIMIT"; return false; }
   if(g_state.consecutiveLosses >= consecutiveLossHalt){ reason="CONSECUTIVE_LOSS_HALT"; return false; }
   if(!SpreadOK(symbol)){ reason="SPREAD_FILTER_FAIL"; return false; }
   string protReason=""; if(!CheckDailyProtections(protReason)){ reason=protReason; return false; }
   return true;
}

bool CheckDailyProtections(string &reason){
   double equity=AccountInfoDouble(ACCOUNT_EQUITY);
   double changePct = g_state.dayStartEquity>0 ? ( (equity - g_state.dayStartEquity)/g_state.dayStartEquity * 100.0 ) : 0.0;
   if(changePct <= -maxDailyLossPercent){ reason="DAILY_LOSS_LIMIT"; return false; }
   if(equity <= g_state.dayStartEquity * (equityFloorPercentOfDayStart/100.0)){ reason="EQUITY_FLOOR"; return false; }
   return true; // dailyProfitLockPercent just informational
}

//==================================================================//
// Order Placement & Management                                     //
//==================================================================//

double ComputeLotSize(const string symbol,double stopLossPoints,double targetRiskCurrency,bool &skip,string &reason){
   skip=false; reason="";
   double point=SymbolInfoDouble(symbol,SYMBOL_POINT); if(point<=0) point=_Point;
   double valPerPoint=PointValuePerPoint(symbol);
   if(valPerPoint<=0){ skip=true; reason="POINT_VALUE_ZERO"; return 0; }
   double rawLots = targetRiskCurrency / (stopLossPoints * valPerPoint);
   double minLot=SymbolInfoDouble(symbol,SYMBOL_VOLUME_MIN); if(minLot<=0) minLot=0.01;
   double maxLot=SymbolInfoDouble(symbol,SYMBOL_VOLUME_MAX); if(maxLot<=0) maxLot=100.0;
   double step =SymbolInfoDouble(symbol,SYMBOL_VOLUME_STEP); if(step<=0) step=0.01;
   if(rawLots < minLot){
      double riskIfMin = stopLossPoints*valPerPoint*minLot;
      double allowed = targetRiskCurrency * (1.0 + allowedRiskTolerancePct/100.0);
      if(riskIfMin > allowed){
         if(skipIfOverRisk){ skip=true; reason="RISK_OVERSHOOT_MIN_LOT"; return 0; }
         else rawLots = minLot; // still proceed but risk overshoot
      } else rawLots = minLot;
   }
   rawLots = MathMin(rawLots,maxLot);
   // round down to step
   double lots = MathFloor(rawLots/step)*step;
   if(lots < minLot) lots=minLot; 
   double actualRisk = stopLossPoints*valPerPoint*lots;
   if(actualRisk > targetRiskCurrency*(1.0 + allowedRiskTolerancePct/100.0) && skipIfOverRisk){ skip=true; reason="RISK_OVERSHOOT"; return 0; }
   return lots;
}

bool PlaceTrade(const string symbol,EntryType et,int bias,double atrPoints,double entryPrice,double compHigh,double compLow,string &reason){
   double stopLossPoints,tp1,tp2; double stopEntryPrice;
   if(!ComputeStopPoints(symbol,bias,atrPoints,stopLossPoints,stopEntryPrice,tp1,tp2,InpSLMode,rrPrimary,rrSecondary)){ reason="STOP_FAIL"; return false; }
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double riskPercent = ComputeAdaptiveRiskPercent();
   double targetRisk = equity * (riskPercent/100.0);
   if(maxDollarRiskPerTrade>0) targetRisk = MathMin(targetRisk,maxDollarRiskPerTrade);
   bool skip=false; string lreason=""; double lots=ComputeLotSize(symbol,stopLossPoints,targetRisk,skip,lreason);
   if(skip){ reason=lreason; return false; }
   int type = bias==1?ORDER_TYPE_BUY:ORDER_TYPE_SELL;
   double point=SymbolInfoDouble(symbol,SYMBOL_POINT); if(point<=0) point=_Point;
   double price = SymbolInfoDouble(symbol, bias==1?SYMBOL_ASK:SYMBOL_BID);
   double sl = bias==1? price - stopLossPoints*point : price + stopLossPoints*point;
   double tpPrice = bias==1? price + tp1*point : price - tp1*point;
   MqlTradeRequest req; MqlTradeResult res; ZeroMemory(req); ZeroMemory(res);
   req.action=TRADE_ACTION_DEAL; req.symbol=symbol; req.magic=baseMagicNumber; req.volume=lots; req.deviation=slippagePoints; req.type=type; req.type_filling=ORDER_FILLING_IOC;
   req.sl=NormalizeDouble(sl,(int)SymbolInfoInteger(symbol,SYMBOL_DIGITS));
   req.tp=NormalizeDouble(tpPrice,(int)SymbolInfoInteger(symbol,SYMBOL_DIGITS));
   req.price=price;
   if(et==ENTRY_COMPRESSION){
      // Use stop order at breakout
      req.action=TRADE_ACTION_PENDING;
      if(bias==1){ req.type=ORDER_TYPE_BUYSTOP; req.price = compHigh + breakoutBufferPoints*point; req.sl=NormalizeDouble(req.price - stopLossPoints*point,(int)SymbolInfoInteger(symbol,SYMBOL_DIGITS)); req.tp=NormalizeDouble(req.price + tp1*point,(int)SymbolInfoInteger(symbol,SYMBOL_DIGITS)); }
      else { req.type=ORDER_TYPE_SELLSTOP; req.price = compLow - breakoutBufferPoints*point; req.sl=NormalizeDouble(req.price + stopLossPoints*point,(int)SymbolInfoInteger(symbol,SYMBOL_DIGITS)); req.tp=NormalizeDouble(req.price - tp1*point,(int)SymbolInfoInteger(symbol,SYMBOL_DIGITS)); }
   }
   if(!OrderSend(req,res) || res.retcode!=10009){
      reason="ORDER_FAIL:"+IntegerToString((int)res.retcode);
      return false;
   }
   // Track
   PositionState *ps=new PositionState; ZeroMemory(ps);
   ps->ticket=res.order; ps->symbol=symbol; ps->entryPrice=price; ps->stopLossPrice=req.sl; ps->takeProfitPrice=req.tp; ps->initialStopPoints=stopLossPoints; ps->initialRiskAmount=stopLossPoints*PointValuePerPoint(symbol)*lots; ps->partialTaken=false; ps->rrPrimary=rrPrimary; ps->rrSecondary=rrSecondary; ps->direction=bias; ps->openTime=TimeCurrent(); ps->isCompressionPending=(et==ENTRY_COMPRESSION); ps->pendingPlacedTime=TimeCurrent(); ps->compressionHigh=compHigh; ps->compressionLow=compLow; ps->expiryBars=pendingExpiryBars; ps->counted=false;
   g_positions.Add(ps);
   reason="OK";
   Log(LOG_IMPORTANT,"ENTRY",symbol+" et="+IntegerToString((int)et)+" risk%="+DoubleToString(riskPercent,2)+" lots="+DoubleToString(lots,2));
   return true;
}

void ApplyTrailing(PositionState &ps,double atrPoints){
   if(trailingMode==TRAIL_NONE) return;
   if(ps.partialTaken==false) return;
   double point=SymbolInfoDouble(ps.symbol,SYMBOL_POINT); if(point<=0) point=_Point;
   double atrTrail = atrPoints * trailingATRMult * point;
   if(trailingMode==TRAIL_ATR){
      if(ps.direction==1){
         double newSL = SymbolInfoDouble(ps.symbol,SYMBOL_BID) - atrTrail; if(newSL > ps.stopLossPrice){
            ModifyPositionSLTP(ps.ticket,newSL,ps.takeProfitPrice);
            ps.stopLossPrice=newSL; Log(LOG_VERBOSE,"TRAIL","Update SL "+DoubleToString(newSL,5));
         }
      } else {
         double newSL = SymbolInfoDouble(ps.symbol,SYMBOL_ASK) + atrTrail; if(newSL < ps.stopLossPrice || ps.stopLossPrice==0){
            ModifyPositionSLTP(ps.ticket,newSL,ps.takeProfitPrice);
            ps.stopLossPrice=newSL; Log(LOG_VERBOSE,"TRAIL","Update SL "+DoubleToString(newSL,5));
         }
      }
   }
}

bool ModifyPositionSLTP(ulong position_ticket,double newSL,double newTP){
   // locate symbol
   for(int i=0;i<PositionsTotal();++i){
      if(PositionSelectByIndex(i) && PositionGetInteger(POSITION_TICKET)==position_ticket){
         string sym=PositionGetString(POSITION_SYMBOL);
         MqlTradeRequest r; MqlTradeResult rs; ZeroMemory(r); ZeroMemory(rs);
         r.action=TRADE_ACTION_SLTP; r.position=position_ticket; r.symbol=sym; 
         if(newSL>0) r.sl=NormalizeDouble(newSL,(int)SymbolInfoInteger(sym,SYMBOL_DIGITS));
         if(newTP>0) r.tp=NormalizeDouble(newTP,(int)SymbolInfoInteger(sym,SYMBOL_DIGITS));
         if(!OrderSend(r,rs)) return false; if(rs.retcode!=10009 && rs.retcode!=10008) return false; return true;
      }
   }
   return false;
}

ulong GetPositionTicketBySymbol(const string symbol){ if(PositionSelect(symbol)) return (ulong)PositionGetInteger(POSITION_TICKET); return 0; }

void ManageOpenPositions(){
   // Refresh actual tickets mapping; remove closed
   for(int i=g_positions.Total()-1;i>=0;--i){
      PositionState *ps=(PositionState*)g_positions.At(i); if(!ps) continue;
      bool alive=false; bool pending=false;
      ulong symPosTicket=GetPositionTicketBySymbol(ps->symbol);
      if(ps->isCompressionPending){
         // Check if original pending order still exists
         bool orderExists=false; for(int o=0;o<OrdersTotal();++o){ if(OrderSelect(o,SELECT_BY_POS,MODE_TRADES)){ if(OrderGetInteger(ORDER_TICKET)==ps->ticket){ orderExists=true; break; } } }
         if(orderExists){
            pending=true;
            int barsPassed = (int)((TimeCurrent()-ps->pendingPlacedTime)/PeriodSeconds(InpChartTF));
            double atrPoints; if(!VolatilityOK(ps->symbol,atrPoints) || !SpreadOK(ps->symbol) || barsPassed>ps->expiryBars){
               MqlTradeRequest rq; MqlTradeResult rr; ZeroMemory(rq); ZeroMemory(rr); rq.action=TRADE_ACTION_REMOVE; rq.order=ps->ticket; if(OrderSend(rq,rr)) Log(LOG_VERBOSE,"PENDING_CANCEL",ps->symbol+" expired/invalid");
               delete g_positions.At(i); g_positions.Delete(i); continue;
            }
            continue; // still pending
         } else {
            // Filled or canceled. If filled, there should be a position now.
            if(symPosTicket>0){ ps->ticket=symPosTicket; ps->isCompressionPending=false; ps->entryPrice=PositionGetDouble(POSITION_PRICE_OPEN); ps->stopLossPrice=PositionGetDouble(POSITION_SL); ps->takeProfitPrice=PositionGetDouble(POSITION_TP); alive=true; }
            else { // canceled
               delete g_positions.At(i); g_positions.Delete(i); continue; }
         }
      } else {
         if(symPosTicket==ps->ticket) alive=true; else alive=false;
      }
      if(!alive){ // closed
         delete g_positions.At(i); g_positions.Delete(i); continue; }
      // Manage active position
      double atrPoints; if(!VolatilityOK(ps->symbol,atrPoints)) atrPoints=ps->initialStopPoints; // fallback
      // Partial TP
      if(partialTPEnabled && !ps->partialTaken){
         double price=SymbolInfoDouble(ps->symbol, ps->direction==1?SYMBOL_BID:SYMBOL_ASK);
         double movePoints = (ps->direction==1)? (price - ps->entryPrice)/SymbolInfoDouble(ps->symbol,SYMBOL_POINT) : (ps->entryPrice - price)/SymbolInfoDouble(ps->symbol,SYMBOL_POINT);
         double R = movePoints / ps->initialStopPoints;
         if(R >= partialTP_R){
            // close partial
            if(PositionSelect(ps->symbol)){
               double volume=PositionGetDouble(POSITION_VOLUME);
               double closeVol = volume * (partialTPPercent/100.0);
               MqlTradeRequest rq; MqlTradeResult rr; ZeroMemory(rq); ZeroMemory(rr); rq.action=TRADE_ACTION_DEAL; rq.symbol=ps->symbol; rq.magic=baseMagicNumber; rq.deviation=slippagePoints; rq.volume=NormalizeDouble(closeVol,2); 
               rq.type= ps->direction==1? ORDER_TYPE_SELL: ORDER_TYPE_BUY; rq.price=SymbolInfoDouble(ps->symbol, ps->direction==1?SYMBOL_BID:SYMBOL_ASK); 
               OrderSend(rq,rr); ps->partialTaken=true; Log(LOG_IMPORTANT,"PARTIAL",ps->symbol+" R="+DoubleToString(R,2));
               // move SL to BE + buffer
               double buffer = ps->initialStopPoints * breakEvenBufferFraction * SymbolInfoDouble(ps->symbol,SYMBOL_POINT);
               double newSL = ps->direction==1? (ps->entryPrice + buffer) : (ps->entryPrice - buffer);
               ModifyPositionSLTP(ps->ticket,newSL,ps->takeProfitPrice);
               ps->stopLossPrice=newSL; Log(LOG_VERBOSE,"SL_BE",ps->symbol);
            }
         }
      }
      // Trailing
      ApplyTrailing(*ps,atrPoints);
   }
}

void RecordClosedTrade(){
   // Iterate history deals recently closed (since start of day) and add new ones
   datetime from = g_state.dayDate; datetime to=TimeCurrent();
   ulong ticketsLogged[]; int logged=0;
   // We'll just scan history orders for today
   HistorySelect(from,to);
   int total=HistoryDealsTotal();
   for(int i=0;i<total;i++){
      ulong dealTicket = HistoryDealGetTicket(i);
      string symbol = (string)HistoryDealGetString(dealTicket,DEAL_SYMBOL);
      long magic = HistoryDealGetInteger(dealTicket,DEAL_MAGIC);
      if(magic!=baseMagicNumber) continue;
      long entryType = HistoryDealGetInteger(dealTicket,DEAL_ENTRY);
      if(entryType!=DEAL_ENTRY_OUT) continue; // only exit deals
      ulong posID = HistoryDealGetInteger(dealTicket,DEAL_POSITION_ID);
      double profit = HistoryDealGetDouble(dealTicket,DEAL_PROFIT) + HistoryDealGetDouble(dealTicket,DEAL_SWAP) + HistoryDealGetDouble(dealTicket,DEAL_COMMISSION);
      // Check if already recorded for that position (we record once per closed position). We'll approximate by searching existing performance records.
      bool exists=false; for(int r=0;r<g_performance.Total();++r){ TradePerformanceRecord *tr=(TradePerformanceRecord*)g_performance.At(r); if(tr && tr.ticket==posID){ exists=true; break; } }
      if(exists) continue;
      // We need original risk. Approx: derive from comment? We stored pos state earlier; attempt to match ticket.
      double riskAmount=0; // find in states vector that might have been removed; cannot guarantee; approximate using profit & R? We'll store map before deletion - to refine we would save risk at opening into global map keyed by position id. For now assume risk 0 if missing.
      // Attempt lookup by scanning g_positions (still open) or by storing past states; improvement future.
      // risk inference skipped if missing.
      double rMultiple=0; if(riskAmount>0) rMultiple = profit / riskAmount;
      TradePerformanceRecord *rec=new TradePerformanceRecord; rec.ticket=posID; rec.riskAmount=riskAmount; rec.profitAmount=profit; rec.rMultiple=rMultiple; rec.closeTime=TimeCurrent(); g_performance.Add(rec);
      // maintain window
      while(g_performance.Total()>winRateWindow*2){ delete g_performance.At(0); g_performance.Delete(0); }
      if(profit<0){ g_state.consecutiveLosses++; } else if(profit>0){ g_state.consecutiveLosses=0; }
      Log(LOG_IMPORTANT,"CLOSE","ticket="+IntegerToString((int)posID)+" profit="+DoubleToString(profit,2));
   }
}

//==================================================================//
// Logging                                                           //
//==================================================================//
void Log(int level,string tag,string msg){ if(level>logVerbosity) return; Print("[",logPrefix,"] ",tag,": ",msg); }

//==================================================================//
// OnInit / OnTick / OnDeinit                                        //
//==================================================================//
int OnInit(){
   ArrayFree(g_symbols); SplitString(InpSymbolsWhitelist,",",g_symbols);
   g_symbolProfiles.Clear(); g_positions.Clear(); g_performance.Clear();
   for(int i=0;i<ArraySize(g_symbols);++i){ string s=StringTrim(g_symbols[i]); if(StringLen(s)==0) continue; SymbolSelect(s,true); SymbolProfile *p=new SymbolProfile; p->symbol=s; p->isGold=IsGold(s); p->minATRPoints=p->isGold?minATRPointsGold:minATRPointsDefault; p->maxATRPoints=p->isGold?maxATRPointsGold:maxATRPointsDefault; p->atrStopMult=p->isGold?atrStopMultGold:atrStopMultDefault; g_symbolProfiles.Add(p); }
   g_state.dayStartEquity=AccountInfoDouble(ACCOUNT_EQUITY); g_state.dayDate=TimeCurrent() - (TimeCurrent()%86400); g_state.peakEquity=g_state.dayStartEquity; g_state.throttleActive=false; g_state.consecutiveLosses=0; g_state.lastAdaptiveRiskPercent=baseRiskPercent; 
   Log(LOG_IMPORTANT,"INIT","EA initialized. Symbols="+IntegerToString((int)g_symbolProfiles.Total()));
   return(INIT_SUCCEEDED);
}

void OnTick(){
   // Daily reset
   datetime today = TimeCurrent() - (TimeCurrent()%86400);
   if(today != g_state.dayDate){
      g_state.dayDate=today; g_state.dayStartEquity=AccountInfoDouble(ACCOUNT_EQUITY); g_state.peakEquity=g_state.dayStartEquity; g_state.consecutiveLosses=0; Log(LOG_IMPORTANT,"DAY_RESET","New day equity="+DoubleToString(g_state.dayStartEquity,2));
   }
   EvaluateDynamicRiskThrottle();
   RecordClosedTrade();
   ManageOpenPositions();

   // Iterate symbols
   for(int i=0;i<g_symbolProfiles.Total();++i){
      SymbolProfile *prof=(SymbolProfile*)g_symbolProfiles.At(i); if(!prof) continue; string sym=prof->symbol;
      string reason=""; if(!AllowNewTrade(sym,reason)){ if(logVerbosity>=LOG_DEBUG) Log(LOG_DEBUG,"SKIP",sym+" reason="+reason); continue; }
      double atrPoints; if(!VolatilityOK(sym,atrPoints)){ Log(LOG_VERBOSE,"VOLATILITY_FILTER_FAIL",sym); continue; }
      int bias=HTFTrendBias(sym); if(bias==0){ Log(LOG_DEBUG,"NO_BIAS",sym); continue; }
      if(!LTFTrendAlignment(sym,bias)){ Log(LOG_DEBUG,"LTF_ALIGN_FAIL",sym); continue; }
      if(!LowerTFConfirm(sym,bias)){ Log(LOG_DEBUG,"LOWER_TF_FAIL",sym); continue; }
      double pullbackPrice,compHigh,compLow; EntryType et=EvaluateEntry(sym,bias,atrPoints,pullbackPrice,compHigh,compLow);
      if(et==ENTRY_NONE) continue;
      if(!PlaceTrade(sym,et,bias,atrPoints,pullbackPrice,compHigh,compLow,reason)){
         Log(LOG_VERBOSE,"ENTRY_REJECT",sym+" reason="+reason);
      }
   }
}

void OnDeinit(const int reason){
   for(int i=0;i<g_symbolProfiles.Total();++i){ delete g_symbolProfiles.At(i); }
   for(int i=0;i<g_positions.Total();++i){ delete g_positions.At(i); }
   for(int i=0;i<g_performance.Total();++i){ delete g_performance.At(i); }
   Log(LOG_IMPORTANT,"DEINIT","EA deinitialized.");
}

//==================================================================//
// NEXT STEPS                                                        //
// FUTURE MODULES: News calendar integration, persistent storage of risk per ticket, improved R multiple capture, swing trailing, multi-position pyramiding control. 
// METRICS TO MONITOR: Win rate, average R, equity curve vs throttle events, distribution of adaptive risk percent, slippage, spread filter rejection counts.
//==================================================================//
